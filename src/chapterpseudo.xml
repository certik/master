<section>
    <title>Pseudopotentials</title>
    <section>
        <title>Introduction</title>
<p>
Literature about pseudopotentials is unfortunately scattered among many
arcticles, so this section gives a review and should save the reader from a lot
of troubles.
</p>
</section>
<section>
    <title>Hermitian Operators in Spherical Symmetry</title>
<p>
We show that every Hermitian operator <m>\hat V</m> in the spherical symmetric
problem (<m>\hat V=R^{-1}\hat VR</m>) can be written in the form
<e id="lmexpansion">\hat V=\sum_{lm}\ket{lm}\hat V_l\bra{lm}</e>
where the operator <m>\hat V_l=\braket{lm|\hat V|lm}</m> has matrix elements
<e>\braket{\rho|\hat V_l|\rho'}=\bra{lm}\braket{\rho|\hat V|\rho'}\ket{lm}=
V_l(\rho,\rho')</e>
{\bf Proof:} Matrix elements of a general Hermitian operator <m>\hat V</m> are
<e>\braket{{\bf r}|\hat V|\varphi}=
\int\braket{{\bf r}|\hat V|{\bf r'}}\braket{{\bf r'}|\varphi}\d^3r'=
\int V({\bf r},{\bf r'})\varphi({\bf r'})\d^3r'</e>
where
<e>V({\bf r}, {\bf r'})=\braket{{\bf r}|\hat V|{\bf r'}}</e> 
In spherical symmetry, we have 
<e>\braket{{\bf r}|\hat V|\varphi}
=\braket{{\bf r}|R^{-1}\hat VR|\varphi}
=\braket{{\bf r}|R^{\dagger}\hat VR|\varphi}
=\int\braket{{\bf r}|R^{\dagger}\hat VR|{\bf r'}}\braket{{\bf r'}|\varphi}\d^3r'
=
</e>
<e>
=\int\braket{R{\bf r}|\hat V|R{\bf r'}}\braket{{\bf r'}|\varphi}\d^3r'
=\int V(R{\bf r},R{\bf r'})\varphi({\bf r'})\d^3r'
</e>
where <m>R</m> is the rotation operator (it's unitary). We have thus derived
<m>V(R{\bf r},R{\bf r'})=V({\bf r},{\bf r'})</m> true for any <m>R</m>, which means that
the
the kernel only depends on <m>\rho</m>, <m>\rho'</m> and 
<m>{\bf\hat r}\cdot{\bf\hat r'}</m>, where <m>{\bf r}=\rho{\bf\hat r}</m> and
<m>{\bf r'}=\rho'{\bf\hat r'}</m>. So we obtain using <a ref="fylm"/>
<e>V({\bf r}, {\bf r'})=V(\rho,\rho',{\bf\hat r}\cdot{\bf\hat r'})=
\sum_{lm}  Y_{lm}({\bf\hat r}) V_l(\rho,\rho')
Y_{lm}^*({\bf\hat r'})</e>
where
<e>V_l(\rho,\rho')={(2l+1)^2\over8\pi}\int_{-1}^1 P_l(x)V_l(\rho,\rho',x)\d x</e>
In Dirac notation:
<e>V({\bf r}, {\bf r'})=\braket{{\bf r}|\hat V|{\bf r'}}
=\bra{\bf\hat r}\braket{\rho|\hat V|\rho'}\ket{\bf\hat r'}
=\sum_{lml'm'}\braket{{\bf\hat r}|lm}\bra{lm}\braket{\rho|\hat V|\rho'}
\ket{l'm'}\braket{l'm'|\bf\hat r'}
</e>
From the above derivation we see that we must have:
<e>\bra{lm}\braket{\rho|\hat V|\rho'}\ket{l'm'}=
V_l(\rho,\rho')\delta_{ll'}\delta_{mm'}</e>
in other words
<e id="vlm2">V_l(\rho,\rho')=\bra{lm}\braket{\rho|\hat V|\rho'}\ket{lm}</e>
so we get
<e>\braket{{\bf r}|\hat V|{\bf r'}}
=\sum_{lm}\braket{{\bf\hat r}|lm}V_l(\rho,\rho')\braket{lm|\bf\hat r'}
=\sum_{lm}Y_{lm}(\theta,\phi) V_l(\rho,\rho') Y_{lm}^*(\theta',\phi')
</e>
and
<e>\hat V 
=\sum_{lm}\ket{lm}\braket{lm|\hat V|lm}\bra{lm} 
=\sum_{lm}\ket{lm}\hat V_l\bra{lm} 
</e>
where the operator <m>\hat V_l=\braket{lm|\hat V|lm}</m> only acts on the radial
part of the wavefunction and according to <a ref="vlm2"/> it doesn't depend on
<m>m</m>. Also according to <a ref="vlm2"/> its matrix elements are
<e>\braket{\rho|\hat V_l|\rho'}=\bra{lm}\braket{\rho|\hat V|\rho'}\ket{lm}=
V_l(\rho,\rho')</e>
</p>
</section>
<section>
    <title>Nonlocal Pseudopotentials</title>
<p>
A nonlocal pseudopotential <m>\hat V</m> is just a general Hermitian operator.
We only want to construct pseudopotentials in the spherical problem, so every
pseudopotential can be written in the form <a ref="lmexpansion"/>.
In practice we only use either {\it local\/} (the operator <m>\hat V</m> is local)
or {\it semilocal\/} (the operator <m>\hat V</m> is radially local, but angularly
nonlocal) pseudopotential.
</p>
<p>
Local potential (radially and angularly local) is defined by:
<e>\braket{{\bf r}|\hat V|{\bf r'}}=V(\rho)\braket{{\bf r}|{\bf r'}}</e>
so we can simply write
<e id="loc1">\hat V=V(\rho)</e>
so
<e>V_l(\rho,\rho')
=\bra{lm}\braket{\rho|\hat V|\rho'}\ket{lm}
=V(\rho)\braket{\rho|\rho'}
=V(\rho){\delta(\rho-\rho')\over\rho^2}</e>
so it turned out that the kernel is local and doesn't depend on <m>l</m> and we get
<e>V({\bf r}(\rho,\theta,\phi), {\bf r'}(\rho',\theta',\phi'))=
\sum_{lm}Y_{lm}(\theta,\phi) V(\rho){\delta(\rho-\rho')\over\rho^2} Y_{lm}^*(\theta',\phi')=
</e>
<e>
=V(\rho){1\over\rho^2\sin\theta}
\delta(\rho-\rho')\delta(\theta-\theta')\delta(\phi-\phi')=
V(\rho)\delta({\bf r}-{\bf r}')</e>
and
<e>\braket{{\bf r}|\hat V|\varphi}=\int 
V(\rho)\delta({\bf r}-{\bf r}')
\varphi({\bf r'})\d^3r'=V(\rho)\varphi({\bf r})</e>
so we recover <a ref="loc1"/>. But we are just fooling around, there's nothing new in these formulas.
</p>
<p>
For a semilocal potential (radially local, but angularly nonlocal), the kernel
cannot depend on <m>m</m> and is radially local, so:
<e>\braket{\rho|\hat V_l|\rho'}=V_l(\rho,\rho')
=\bra{lm}\braket{\rho|\hat V|\rho'}\ket{lm}
=V_l(\rho)\braket{\rho|\rho'}
=V_l(\rho){\delta(\rho-\rho')\over\rho^2}</e>
so the kernel is local and does depend on <m>l</m> and we simply write
<e>\hat V_l=V_l(\rho)</e>
and
<e id="semi">\hat V=\sum_{lm} \ket{lm}V_l(\rho)\bra{lm}</e>
We can also calculate the same result explicitly in the <m>\bf r</m>
representation:
<e>V({\bf r}(\rho,\theta,\phi), {\bf r'}(\rho',\theta',\phi'))=
\sum_{lm}Y_{lm}(\theta,\phi) V_l(\rho){\delta(\rho-\rho')\over\rho^2} Y_{lm}^*(\theta',\phi')
</e>
and
<e>\braket{{\bf r}|\hat V|\varphi}=\int 
\sum_{lm}Y_{lm}(\theta,\phi) V_l(\rho){\delta(\rho-\rho')\over\rho^2} Y_{lm}^*(\theta',\phi')
\varphi({\bf r'})\d^3r'=</e>
<e>=
\sum_{lm}Y_{lm}(\theta,\phi) V_l(\rho) \int Y_{lm}^*(\theta',\phi')
\varphi(\rho{\bf\hat r'})\d\Omega'
</e>
or in Dirac notation
<e>\braket{{\bf r}|\hat V|\varphi}=
\sum_{lm} \braket{{\bf\hat r}|lm}V_l(\rho) \bra{lm}\braket{\rho|\varphi}
</e>
and we recover <a ref="semi"/>.
</p>
<p>
So, to sum it up: semilocal pseudopotential is a general hermitian operator
in the spherically symmetric problem (i.e. <m>\hat V=R^{-1}\hat VR</m>) and radially
local. All such operators can be written in the form <a ref="semi"/>.
</p>
<p>
Now, it can be shown that if we make the assumption of radial locality, we get
"correct" wavefunctions and energies in the linear approximation. We generally
only take a few terms in the expansion <a ref="semi"/>, usually only <m>V_0</m>,
<m>V_1</m> and <m>V_2</m>, sometimes also <m>V_3</m> and <m>V_4</m>.
</p>
</section>
<section>
    <title>Separable Potentials</title>
<p>
The pseudopotential above (Hamman, Schl&uuml;ter, Chiang) has the form
<e>\hat V=\sum_{lm} \ket{lm}V_l(\rho)\bra{lm}
=V_{loc}(\rho)+\sum_{lm} \ket{lm}[V_l(\rho)-V_{loc}(\rho)]\bra{lm}</e>
Or, equivalently, in the <m>\bf r</m> representation:
<e>V({\bf r},{\bf r'})=\braket{{\bf r}|\hat V|{\bf r'}}=
V_{loc}(\rho)\delta({\bf r}-{\bf r'})+{\delta(\rho-\rho')\over\rho^2}
\sum_{lm}Y_{lm}({\bf\hat r})[V_l(\rho)-V_{loc}(\rho)]Y_{lm}^*({\bf\hat r'})</e>
The first term doesn't cause a problem. Let's denote the second term (which is
semilocal) simply by <m>v</m>:
<e>v=\sum_{lm} \ket{lm}[V_l(\rho)-V_{loc}(\rho)]\bra{lm}</e>
Let's choose a complete but otherwise arbitrary set of functions
<m>\ket{\phi_i}</m> (they contain both a radial and an angular dependence) and
define a matrix <m>U</m> is by the equation
<e>\sum_j U_{ij}\braket{\phi_j|v|\phi_k}=\delta_{ik}</e>
then (<m>\ket{\psi}=\ket{\phi_k}\alpha_k</m>):
<e>v\ket{\psi}
=\sum_{ik}v\ket{\phi_i}\delta_{ik}\alpha_k
=\sum_{ijk}v\ket{\phi_i}U_{ij}\braket{\phi_j|v|\phi_k}\alpha_k
=\sum_{ij}v\ket{\phi_i}U_{ij}\braket{\phi_j|v|\psi}
</e>
So any Hermitian operator (including <m>v</m>) can be transformed exactly into the
following form
<e>v=\sum_{ij}v\ket{\phi_i}U_{ij}\bra{\phi_j}v</e>
We diagonalize the matrix <m>U</m> by choosing
such functions <m>\ket{\bar\phi_i}</m> for which the matrix
<m>\braket{\bar\phi_j|v|\bar\phi_k}</m> (and hence the corresponding matrix <m>U</m>) is
equal to \one. We can find such functions for example using the Gram-Schmidt
orthogonalization procedure on <m>\ket{\phi_i}</m> with a norm <m>\braket{f|v|g}</m> (for
functions <m>f</m> and <m>g</m>), more on that later. Then 
<e id="vsep">v
=\sum_{i}v\ket{\bar\phi_i}{1\over\braket{\bar\phi_i|v|\bar\phi_i}}
\bra{\bar\phi_i}v 
=\sum_{i}v\ket{\bar\phi_i}\bra{\bar\phi_i}v</e>
We could take any <m>\ket{\phi_i}</m> and orthogonalize them. But because we have
<m>v</m> in the form of <a ref="semi"/>, we will be using <m>\ket{\phi_i}</m> in the form
<m>\ket{\phi_i}=\ket{R_{nl}}\ket{lm}</m>, because it turns out we will only need to orthogonalize the radial
parts. The first term in <a ref="vsep"/> then corresponds to
the KB potential. We of course take more terms and get accurate results without
ghost states.
</p>
<p>
Let's look at the orthogonalization. We start with the 
wavefunctions:
<e>\ket{\phi_i}=\ket{R_{nl}}\ket{lm}</e>
where <m>R_{nl}(\rho)=\braket{\rho|R_{nl}}</m> and <m>i</m> goes over all possible
triplets <m>(nlm)</m>, for example in this order (but any order is fine):
</p>
<p>
FIXME

FIXME
%\vbox{\hfil\vbox{
%\halign{
%\hfill<m>#</m>\quad &amp; <m>#</m>\quad &amp; <m>#</m>\quad &amp; \hfill<m>#</m>\cr
%i &amp; n &amp; l &amp; m \cr
%\noalign{\smallskip \hrule \smallskip}
%1 &amp; 1 &amp; 0 &amp; 0 \cr
%2 &amp; 2 &amp; 0 &amp; 0 \cr
%3 &amp; 2 &amp; 1 &amp; -1 \cr
%4 &amp; 2 &amp; 1 &amp; 0 \cr
%5 &amp; 2 &amp; 1 &amp; 1 \cr
%6 &amp; 3 &amp; 0 &amp; 0 \cr
%7 &amp; 3 &amp; 1 &amp; -1 \cr
%8 &amp; 3 &amp; 1 &amp; 0 \cr
%9 &amp; 3 &amp; 1 &amp; 1 \cr
%10 &amp; 3 &amp; 2 &amp; -2 \cr
%11 &amp; 3 &amp; 2 &amp; -1 \cr
%\noalign{\hbox{\quad\quad\dots}}
%}
%}\hfil}
</p>
<p>
We can also relate the <m>i</m> and <m>n</m>, <m>l</m>, <m>m</m> using this formula
<e>i_{nlm}=\sum_{k=1}^{n-1}k^2+\left(\sum_{k=0}^{l-1} (2k+1)\right) + (l+m+1)=
{(n-1)n(2n-1)\over6} + l(l+1)+m+1</e>
</p>
<p>
The operator <m>v</m> acts on these <m>\ket{\phi_i}</m> like this
<e>
\braket{{\bf r}|v|\phi_i}
=\braket{{\bf r}|v|R_{nl}}\ket{lm}
=\bra{{\bf\hat r}}\braket{\rho|V_l(\rho)|R_{nl}}\ket{lm}
=V_l(\rho)R_{nl}(\rho)Y_{lm}({\bf\hat r})</e>
Now we need to construct new orthogonal set of functions <m>\ket{\bar\phi_i}</m> 
satisfying
<e>\braket{\bar\phi_i|v|\bar\phi_j}=\delta_{ij}</e>
This can be done using several methods, we chose the Gram-Schmidt
orthogonalization procedure, which works according to the following scheme:
<align>
<e>
\ket{\tilde\phi_1}=\one{1\over\sqrt{\braket{\phi_1|v|\phi_1}}}\ket{\phi_1}
;\quad\quad 
\quad\quad\quad\quad\quad
\quad\quad\quad\quad\quad
 \ket{\bar\phi_1}={1\over\sqrt{\braket{\tilde\phi_1|v|\tilde\phi_1}}}
 \ket{\tilde\phi_1}</e>
<e>
\ket{\tilde\phi_2}=
\left(\one
-\ket{\bar\phi_1}\bra{\bar\phi_1}v
\right){1\over\sqrt{\braket{\phi_2|v|\phi_2}}}\ket{\phi_2};\quad\quad
\quad\quad\quad\quad\quad
 \ket{\bar\phi_2}={1\over\sqrt{\braket{\tilde\phi_2|v|\tilde\phi_2}}}
 \ket{\tilde\phi_2}</e>
<e>
\ket{\tilde\phi_3}=
\left(\one
-\ket{\bar\phi_1}\bra{\bar\phi_1}v
-\ket{\bar\phi_2}\bra{\bar\phi_2}v
\right){1\over\sqrt{\braket{\phi_3|v|\phi_3}}}\ket{\phi_3};\quad\quad
 \ket{\bar\phi_3}={1\over\sqrt{\braket{\tilde\phi_3|v|\tilde\phi_3}}}
 \ket{\tilde\phi_3}</e>
<e>
    \dots</e>
</align>
We can verify by a direct calculation that this procedure ensures
<e>\braket{\bar\phi_i|v|\bar\phi_j}=\delta_{ij}</e>
It may be useful to compute the normalization factors explicitly:
<align>
<e>
    \braket{\tilde\phi_1|v|\tilde\phi_1}=1</e>
<e>
\braket{\tilde\phi_2|v|\tilde\phi_2}=1
  -{\braket{\phi_2|v|\bar\phi_1}\braket{\bar\phi_1|v|\phi_2}
  \over\braket{\phi_2|v|\phi_2}}</e>
<e>
\braket{\tilde\phi_3|v|\tilde\phi_3}=1
  -{\braket{\phi_3|v|\bar\phi_1}\braket{\bar\phi_1|v|\phi_3}+
    \braket{\phi_3|v|\bar\phi_2}\braket{\bar\phi_2|v|\phi_3}
    \over\braket{\phi_3|v|\phi_3}}</e>
<e>
    ...</e>
</align>
we can also write down a first few orthogonal vectors explicitly:
<align>
<e>
    \ket{\bar\phi_1}={\ket{\phi_1}\over\sqrt{\braket{\phi_1|v|\phi_1}}}</e>
<e>
\ket{\bar\phi_2}={\ket{\phi_2}\braket{\phi_1|v|\phi_1}-\ket{\phi_1}\braket{\phi_1|v|\phi_2}
\over\sqrt{(\braket{\phi_1|v|\phi_1}\braket{\phi_2|v|\phi_2}-\braket{\phi_2|v|\phi_1}\braket{\phi_1|v|\phi_2})\braket{\phi_1|v|\phi_1}\braket{\phi_2|v|\phi_2}}}
</e>
</align>
Now the crucial observation is
<e>\bra{lm}\braket{R_{nl}|v|R_{n'l'}}\ket{l'm'}=
\braket{R_{nl}|V_l(\rho)|R_{n'l}}\delta_{ll'}\delta_{mm'} </e>
which means that <m>\braket{\phi_i|v|\phi_j}=0</m> if <m>\ket{\phi_i}</m> and
<m>\ket{\phi_j}</m> have different <m>l</m> or <m>m</m>. In other words
<m>\ket{\phi_i}</m> and <m>\ket{\phi_j}</m> for different <m>\ket{lm}</m> are already
orthogonal.
Thus the G-S orthogonalization
procedure only makes the <m>R_{nl}</m> orthogonal for the same <m>\ket{lm}</m>. To get
explicit expressions for <m>\ket{\bar\phi_i}</m>, we simply use the formulas above
and get:
<e>\ket{\phi_i}=\ket{R_{nl}}\ket{lm}\quad\to\quad
\ket{\bar\phi_i}=\ket{\bar R_{nl}}\ket{lm}
</e>
where we have constructed new <m>\ket{\bar R_{nl}}</m> from original <m>\ket{R_{nl}}</m>:
<align>
<e>
    \ket{\bar
    R_{10}}={\ket{R_{10}}\over\sqrt{\braket{R_{10}|V_0|R_{10}}}}</e>
<e>
\ket{\bar R_{20}}={\ket{R_{20}}
-\ket{\bar R_{10}}\braket{\bar R_{10}|V_0|R_{20}}\over\sqrt{\dots}}</e>
<e>
    \ket{\bar
    R_{21}}={\ket{R_{21}}\over\sqrt{\braket{R_{21}|V_1|R_{21}}}}</e>
<e>
\ket{\bar R_{30}}={\ket{R_{30}}
  -\ket{\bar R_{10}}\braket{\bar R_{10}|V_0|R_{30}}
  -\ket{\bar R_{20}}\braket{\bar R_{20}|V_0|R_{30}}
  \over\sqrt{\dots}}</e>
  <e>
\ket{\bar R_{31}}={\ket{R_{31}}
  -\ket{\bar R_{21}}\braket{\bar R_{21}|V_1|R_{31}}
  \over\sqrt{\dots}}</e>
  <e>
      \ket{\bar
      R_{32}}={\ket{R_{32}}\over\sqrt{\braket{R_{32}|V_1|R_{32}}}}</e>
  <e>
\ket{\bar R_{40}}={\ket{R_{40}}
  -\ket{\bar R_{10}}\braket{\bar R_{10}|V_0|R_{40}}
  -\ket{\bar R_{20}}\braket{\bar R_{20}|V_0|R_{40}}
  -\ket{\bar R_{30}}\braket{\bar R_{30}|V_0|R_{40}}
  \over\sqrt{\dots}}</e>
  <e>
\ket{\bar R_{41}}={\ket{R_{41}}
  -\ket{\bar R_{21}}\braket{\bar R_{21}|V_1|R_{41}}
  -\ket{\bar R_{31}}\braket{\bar R_{31}|V_1|R_{41}}
  \over\sqrt{\dots}}</e>
  <e sep="\dots">
\dots</e>
</align>
Ok, so we have constructed new <m>\ket{\bar R_{nl}}</m> from <m>\ket{R_{nl}}</m> which
obey
<e id="orthog">\braket{\bar R_{nl}|V_l|\bar R_{n'l}}=\delta_{nn'}</e>
so for every <m>V_l</m>, we construct <m>\ket{\bar R_{nl}}</m> for <m>n=l+1,\,\, l+2,
\cdots</m>.
Let's
continue:
<e>v\ket{\bar\phi_i}=V_l(\rho)\ket{\bar R_{nl}}\ket{lm}</e>
and finally we arrive at the separable form of the <m>l</m> dependent
pseudopotential
<e id="Vsep">v
=\sum_{i}v\ket{\bar\phi_i}\bra{\bar\phi_i}v 
=\sum_{i}V_l(\rho)\ket{\bar R_{nl}}\ket{lm}
\bra{lm}\bra{\bar R_{nl}}V_l(\rho)</e>
Note: the <m>V_l</m> is actually <m>V_l-V_{loc}</m>, but this is just a detail.
</p>
<p>
To have some explicit formula, let's write how the separable potential acts on
a wavefunction:
<e>(v\psi)({\bf r})=\braket{{\bf r}|v|\psi}= 
\sum_i\braket{{\bf\hat r}|lm}\braket{\rho|V_l(\rho)|\bar R_{nl}}
\bra{\bar R_{nl}}V_l(\rho)\braket{lm|\psi}=</e>
<e>
=\sum_iY_{lm}({\bf\hat r})\bar R_{nl}(\rho)V_l(\rho)
\int \bar R_{nl}(\rho')V_l(\rho')\int Y_{lm}^*({\bf\hat r'})\psi({\bf r'})\,\d
\Omega'\,\rho'^2 \d\rho'=</e>
<e>
=\sum_iY_{lm}({\bf\hat r})\bar R_{nl}(\rho)V_l(\rho)
\int \bar R_{nl}(\rho')V_l(\rho') Y_{lm}^*({\bf\hat r'})\psi({\bf r'})\,\d^3r' 
</e>
</p>
<p>
To have some insight on what we are actually doing: we are making the local
potential <m>V_l</m> nonlocal using:
<e id="Vlsep">V_l=\sum_{n=l+1}^\infty V_l\ket{\bar R_{nl}}\bra{\bar R_{nl}}V_l</e>
where
<e>\braket{\bar R_{nl}|V_l|\bar R_{n'l}}=\delta_{nn'}</e>
or in <m>{\bf r}</m> representation:
<e>V_l(\rho)\psi(\rho {\bf\hat r})=\sum_n V_l(\rho)\bar R_{nl}(\rho)
\int\bar R_{nl}(\rho')V_l(\rho')\psi(\rho'{\bf\hat r})\rho'^2\d \rho'</e>
which is useful when computing integrals of this type
<e>V_{ij}
=\int\phi_i(\rho) V_l \phi_j(\rho) \rho^2\d^3 \rho
=\braket{i|V_l|j}=
\sum_n \braket{i|V_l|{\bar R_{nl}}}\braket{\bar R_{nl}|V_l|j}
</e>
<e>\braket{i|V_l|{\bar R_{nl}}}=\int\phi_i(\rho)V_l(\rho)\bar R_{nl}(\rho)
\rho^2\d\rho</e>
because the integral on the left hand side actually represents <m>N^2</m> integrals,
where <m>N</m> is the number of basis vectors <m>\ket{\phi_i}</m>. The sum on the
right hand side however only represents <m>K\cdot N</m> integrals, where <m>K</m> is the
number of terms taken into account in <a ref="Vlsep"/>. Of course taking only finite
number of terms in <a ref="Vlsep"/> is only an approximation to <m>\hat V_l</m>. In our
case, we don't need these 1D integrals (which can be easily computed directly,
because <m>V_l</m> is local and the basis functions <m>\phi_i</m> are nonzero only around
a node in the mesh, which means that the matrix <m>V_{ij}</m> is sparse), but 3D
integrals, where angular parts of <m>V</m> are nonlocal and radial part is local (so
the matrix <m>V_{ij}</m> is dense), so the above procedure is the only way how to
proceed, because we decompose the matrix <m>V_{ij}</m> into the sum of matrices in
the form <m>p_ip_j^*</m>, which can easily be handled and solved.
</p>
<p>
The scheme for the separation described
above works for any functions <m>R_{nl}(\rho)</m>. 
Because of the form of the expansion
<a ref="Vlsep"/> however, we will use <m>R_{nl}</m> from one atomic calculation.
We need to approximate <m>V_l</m> by as few terms as
possible, 
so imagine how the <m>V_l(\rho)</m> acts on the lowest radial function in the <m>l</m>
subspace, which is <m>\ket{R_{l+1;l}}</m> and we see that all the terms in
<a ref="Vlsep"/> except the first one 
<m>V_l\ket{\bar R_{l+1;l}}\bra{\bar R_{l+1;l}}V_l</m>
give zero, because they are orthogonal to <m>\ket{R_{l+1;l}}</m>. For the function
<m>\ket{R_{l+2;l}}</m> all the terms except the first two are zero, because
<m>\braket{\bar R_{nl}|V_0|R_{l+2;l}}\neq0</m> only for <m>n=l+1</m> or <m>n=l+2</m> 
(because the vectors
<m>\ket{R_{l+1;l}}</m> and <m>\ket{R_{l+2;l}}</m> span the same subspace as
<m>\ket{\bar R_{l+1;l}}</m> and <m>\ket{\bar R_{l+2;l}}</m> and using <a
    ref="orthog"/>)
For functions, which are a little different from all <m>\ket{R_{nl}}</m> (<m>n>l</m>),
we won't genereally get precise results taking any (finite) number of terms
in <a ref="Vlsep"/>, but the higher terms should give smaller and smaller
corrections.
</p>
<p>
    So, to sum it up: We take all the <m>V_l</m> in <a ref="Vsep"/>  as we did
    in <a ref="semi"/>.
Theoretically we should take <m>\bar R_{nl}</m> for all 
<m>n=l+1,\,\, l+2,\,\,l+3,\dots</m>, 
but practically it suffices to only take several <m>\bar R_{nl}</m> for a given <m>l</m>
from one atomic calculaction.
</p>
<p>
Let's give an example: we are calculating 14 electrons, so we will only
take into account the lowest 14 eigenvalues in the Kohn sham equations, which
are <m>\ket{\phi_1}</m> up to <m>\ket{\phi_{14}}</m>. The lowest radial functions in each
<m>l</m> subspace are <m>\ket{\phi_i}</m> for <m>i=1,3,4,5,10,11,12,13,14</m> and on these 9
functions we get a precise result with only one term in the expansion
<a ref="Vlsep"/>. For the other 5 functions (<m>i=2,6,7,8,9</m>) we will have to take into
account more terms. Let's look in more detail at the case <m>l=0</m> (i.e.
<m>i=1,2,6</m>). Then 
<e>V_0=
V_0\ket{\bar R_{10}}\bra{\bar R_{10}}V_0+
V_0\ket{\bar R_{20}}\bra{\bar R_{20}}V_0+
V_0\ket{\bar R_{30}}\bra{\bar R_{30}}V_0+
\dots
</e>
and for the case <m>i=1</m> we see that one term in <a ref="Vlsep"/> is enough:
<e>v\ket{\phi_1}=v\ket{R_{10}}\ket{00}=V_0\ket{R_{10}}\ket{00}=
V_0\ket{\bar R_{10}}\bra{\bar R_{10}}V_0\ket{R_{10}}\ket{00}
</e>
because <m>\braket{\bar R_{n0}|V_0|R_{10}}=0</m> for <m>n>1</m>.
For the case <m>i=2</m> we get the correct result with 2 terms in <a
    ref="Vlsep"/>
<e>v\ket{\phi_2}=v\ket{R_{20}}\ket{00}=V_0\ket{R_{20}}\ket{00}=(
V_0\ket{\bar R_{10}}\bra{\bar R_{10}}V_0\ket{R_{20}}+
V_0\ket{\bar R_{20}}\bra{\bar R_{20}}V_0\ket{R_{20}}
)\ket{00}
</e>
because <m>\braket{\bar R_{n0}|V_0|R_{20}}=0</m> for <m>n>2</m>.
For the case <m>i=6</m> we need to take into account 3 terms etc. 
We can see from this example, that taking <m>\ket{R_{nl}}</m> from one atomic
calculation, we get precise results (with the same atom) only taking into
account a finite number of terms in <a ref="Vlsep"/>, for 14 electrons actually only
3 terms. For several atoms calculation, we won't get precise results, but it
should be a sufficiently good approximation.
</p>
<p>
The described method is general, the only drawback is that if we don't take
functions <m>\ket{R_{nl}}</m> which are similar to the solution, we need to take a
lot of terms in <a ref="Vlsep"/>, resulting in many matrices of the form <m>p_ip_j^*</m>,
which we don't want, even though, theoretically we can get a solution with any
precision we want taking more and more terms in <a ref="Vlsep"/>.
</p>
<p>
See also \cite{blochl}.
        </p>
    </section>
</section>
